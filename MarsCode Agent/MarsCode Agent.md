# MarsCode Agent: AI原生自动化Bug修复系统

## 论文概述

此论文介绍了MarsCode Agent，一个利用大型语言模型(LLMs)自动识别和修复软件代码中bug的创新框架。该框架结合LLMs与高级代码分析技术，实现精确的故障定位和补丁生成。在SWE-bench评估中，MarsCode Agent取得了34%的bug修复成功率，显著优于现有大多数自动化方法。

## 核心贡献

### 多智能体协作框架
- 根据问题性质分配静态或动态解决流程，灵活适应各种bug修复挑战
- 包含六种角色智能体：Searcher（搜索者）、Planner（规划者）、Reproducer（复现者）、Programmer（程序员）、Tester（测试者）和Editor（编辑者）
- 每个智能体配备特定工具集，承担明确责任，降低每阶段任务难度

### 代码分析与检索能力
- **代码知识图谱(CKG)**：以图结构表示代码元素及关系，支持12种编程语言
- **语言服务器协议(LSP)**：实现全局精准代码定位，解决标准库和第三方库引用问题
- **模糊定位功能**：增强智能体使用LSP工具的能力，降低对精确数值定位的依赖

### 高效代码编辑
- **AutoDiff工具**：类似git冲突标记的代码更改描述，避免行号计算问题
- **静态代码诊断**：使用LSP验证修改合法性，防止引入新的语法错误
- **多方案投票机制**：生成多个候选修复方案，通过投票选择最优解决方案

### 动态调试能力
- 基于Docker的容器化沙盒环境，模拟真实开发调试流程
- 支持缺陷复现、日志添加和测试框架执行
- 通过异常栈分析和变量跟踪发现复杂逻辑错误

## 方法实现过程

### 多智能体协作框架详细实现

#### 智能体角色与职责分配
1. **Searcher (搜索者)**
   - 负责收集与当前问题相关的代码片段
   - 使用工具：代码知识图谱(CKG)、语言服务器协议(LSP)、文件索引、bash命令
   - 执行方式：通过实体识别、语义匹配和关键词查询三种路径收集代码信息

2. **Planner (规划者)**
   - 负责分析问题性质并决定解决路径
   - 分析代码片段，根据问题复杂度和类型选择动态调试或静态修复流程
   - 对于异常栈和复杂逻辑错误优先选择动态调试；对于简单功能扩展和明确缺陷选择静态修复

3. **Reproducer (复现者)**
   - 仅在动态调试流程中使用
   - 基于问题描述和相关代码编写复现脚本
   - 使用Docker环境验证错误是否可复现，确定异常堆栈和错误模式

4. **Programmer (程序员)**
   - 在动态调试流程中负责代码修改
   - 根据Tester返回的异常信息修改代码
   - 可以重置代码库进行全新尝试或在现有代码基础上迭代修改

5. **Tester (测试者)**
   - 负责验证修复有效性
   - 使用复现脚本在沙盒环境执行测试
   - 捕获执行输出、异常栈和其他调试信息

6. **Editor (编辑者)**
   - 在静态修复流程中使用
   - 基于问题描述和代码片段生成多个候选修复方案
   - 使用AST规范化后进行方案合并和投票

#### 工具分配策略
论文中的表1详细列出了各智能体可使用的工具矩阵，明确限制每个智能体的能力范围：
- 只有Programmer和Editor能进行代码编辑
- 只有Reproducer和Tester能执行复现脚本
- 只有Programmer能重置代码库

### 代码知识图谱(CKG)构建与检索过程

1. **图结构设计**
   - 节点：表示代码实体（函数、变量、类等）
   - 边：表示实体间关系（函数调用、变量引用、类继承等）
   - 属性：存储位置、类型、名称和依赖关系

2. **图构建流程**
   - 使用程序分析技术解析代码和文档
   - 构建多向图，包含语义节点和三类边（文件结构关系、函数调用关系、符号索引关系）
   - 为每个节点和边分配唯一标识符，确保跨代码库唯一性
   - 存储代码定义和注释，增强语义理解

3. **代码检索管道**
   - 实体识别：使用模型识别查询中的实体提及和类型，在知识图谱中查询
   - 语义匹配：将查询和代码语句嵌入向量空间，进行相似度匹配
   - 关键词检索：通过关键词识别转换为SQL查询
   - 融合排序：使用公式`X = Rank(Merge(C₁, C₂, C₃))`合并候选列表，通过细粒度排名模型生成最终列表

4. **语言服务器协议(LSP)集成**
   - 用于解决CKG无法处理的跨项目引用问题
   - 实现了三层模糊定位功能：
     a. 基于文件名和行号查找标识符，计算列号
     b. 搜索附近行的标识符作为备选
     c. 在已浏览文件中查找匹配标识符

### AutoDiff代码编辑工具实现

1. **编辑描述格式设计**
   作者总结了三种失败的代码编辑方法：
   - 统一diff格式：LLMs难以正确计算行号增量
   - 行号范围替换：即使有行号提示，LLMs仍经常提供错误范围
   - 整文件重写：对长文件不经济且不可行

2. **AutoDiff工作原理**
   - 类似git冲突标记格式：提供文件路径、原始代码片段和替换代码
   - 实现步骤：
     a. 解析编辑块，提取原始代码和替换代码
     b. 在目标文件中查找最相似的代码段落（避免精确匹配问题）
     c. 替换目标段落，并根据上下文自动调整缩进
     d. 生成统一diff格式的变更文件，但不实际写入
     e. 将修改传递给静态代码诊断工具验证

3. **静态代码诊断流程**
   - 对修改前后的文件内容使用LSP进行静态分析
   - 比较诊断结果，检查是否引入新的静态错误（Fatal和Error级别）
   - 如果无新错误，完成修改并返回成功消息
   - 如果有新错误，返回诊断信息给智能体进行修正

### 动态调试与静态修复流程

1. **动态调试详细流程**
   - Reproducer创建匹配问题描述的复现脚本
   - Docker容器中执行脚本，验证问题复现
   - 捕获异常栈和输出信息传递给Programmer
   - Programmer修改代码后，重新在容器中执行测试
   - 循环迭代直到修复成功或达到最大尝试次数
   - 成功修复后使用diff工具生成变更补丁

2. **静态修复详细流程**
   - Searcher收集相关代码片段传递给Editor
   - Editor在单个LLM请求中生成多个候选修复方案
   - 使用AST解析规范化所有候选代码
   - 比较规范化后的AST结构，合并相似修复
   - 使用投票机制选择最多数量智能体生成的相似修复作为最终方案
   - 应用静态代码诊断验证最终方案

3. **Planner决策逻辑**
   - 分析问题类型（测试失败、输出不符合预期、功能扩展等）
   - 评估相关代码的复杂度和依赖关系
   - 识别是否存在异常栈和明确的错误消息
   - 根据以上信息选择最适合的修复路径

## 实验结果

### SWE-bench Lite性能
- **总解决率**：34%（102/300实例）
- **文件定位精度**：88.3%（265/300）
- **代码段定位精度**：68.7%（206/300）
- **动态调试成功率**：38.1%（32/84）
- **静态修复成功率**：32.4%（70/216）

### 工具对比
| 系统 | 解决率 | 文件定位精度 |
|------|--------|--------------|
| MarsCode Agent | 34% | 88.3% |
| Agentless | 22% | 78% |
| CodeR | 18% | 65% |
| Moatless | 12% | 52% |

### 修复类型分析
- 72%问题适合静态修复方法
- 28%问题需要动态调试方法
- 动态调试成功率略高，证明复杂问题需要运行时分析

## 应用价值与未来展望

### 应用价值
- 显著降低软件维护成本
- 适用于大规模企业级代码库
- 支持多语言多场景的灵活适配

### 未来展望
- 降低LLM调用成本
- 改善用户-智能体协作体验
- 集成真实开发环境动态调试
- 提高错误定位和代码修改精度

## 总结

MarsCode Agent通过多智能体协作与混合代码分析技术，为自动化软件维护提供了新范式。其创新之处在于将LLM智能体与专业软件工程工具相结合，实现了从代码检索、故障定位到补丁生成、验证的全流程自动化。在SWE-bench Lite上的优异表现证明了其在处理真实世界软件修复任务的有效性，为未来全自动软件开发铺平了道路。